---
date: 2014-04-03 20:00:00
layout: post
title: AspectJ软件体系结构分析
thread: 102
categories: Documents
tags: [Aspectj]
excerpt: 
---

##一、前言

这学期开了一门课程叫做《软件体系结构与设计模式》，第一次从项目汇报要求从以下几个方面进行汇报：了解 AspectJ 的组成元素、联接方式、结构模版、限制、风格以及分析软件设计合理性等。

在连日赶工做好PPT汇报完后，为了方便以后愿意研究Aspectj的大家，特意将我们小组的资料整理出来，以供参考。

----

##二、Aspectj综述与AOP介绍

AspectJ是目前最完善的AOP语言，它支持JAVA平台编译，是对Java编程语言的扩展，通过增加了一些新的构造块支持对横切关注点的模块化封装，通过对源代码级别的代码混合实现织入，是一种典型的使用静态织入的AOP实现机制。而AOP 是一个概念以及规范，本身并没有设定具体语言的实现。英文全称为Aspect-Oriented Programming，中文有翻译成“面向方面编程”一说。

为什么会有AOP的产生？

传统的编程技术倾向于按照功能或行为对软件系统进行分割，这个分割的结果是实现某一功能的模块，如函数、过程、类等。但在编程实践中，人们认识到，软件系统中有些行为无法封装在单个的模块中，例如日志记录、事物处理、对上下文敏感的错误处理、性能优化等等。通常这些功能与行为不实现系统的业务功能，但辅助这些功能的实现，并散布在实现系统功能的诸多模块中，从而造成代码的纠结，这使得实现系统功能的模块的代码难于阅读、理解、调试、维护和扩展等，并使得纠结的代码难于复用。如果我们将实现系统业务功能的模块看作系统的纵向分解单元，那么上述分散在功能模块中的功能与行为就形成了一种横向的方面（Aspect），方面与模块形成了横切（Crosscutting），从而造成传统的编程技术无法将方面模块化，造成两种代码纠结（Tangling）在一起。

对于这类行为的特点描述是：其实现功能与行为并不实现系统的业务功能，但若能将他们横向模块化加以实现，能使的代码更加容易阅读与维护，并增加代码的复用性。

于是乎，应运而生了一种新的编程思想：**对系统中的横切方面进行处理，解决由此造成的代码纠结问题，并使方面可模块化，促进功能模块与方面彼此的复用。**

----

##三、AOP基本思想

如前所述，造成代码纠结的原因在于传统编程技术中，软件系统中非业务功能实现的代码无法模块化，散布在实现业务功能的代码中造成的。这里，我们引入关注点（Concern）的概念，关注点就是软件系统中需要解决的问题。软件系统的业务功能组成了核心关注点（Core Concerns），也就是软件系统要解决的问题，而诸如日志记录，事物处理等关注点就形成了横切关注点（Crosscutting Concerns），因为，这些关注点散布在核心关注点中，相互形成了横切的关系，横切关注点也就是前面提到的方面这一概念。
　　
![](/assets/2014-04-03-AspectjStructure1.png "横向与纵向方面关注点分析图")

<em>横向与纵向方面关注点分析图</em>

有鉴于此，AOP提出的解决方法是对这两种相互横切的关注点分别进行编码，使用传统的编程语言对核心关注点编程，使用面向方面的编程语言对横切关注点，也就是方面进行编程。然后使用一种机制将这两种代码自动混合起来，形成最终的代码。在这里，面向方面的编程语言可以是已有编程语言的扩展（AspectJ，AspectC++，AspectC，AspectC#，Apostle等），或是一种新的语言，设计用于编写方面的代码（Caesar，D2AL，JasCo等）。而将两种代码混合的机制称为织入（Weaving），实现这一机制的工具称为织入器（Weaver）。因此，对方面单独编码，并通过适当的织入机制使两种代码混合，构成了AOP解决代码纠结问题的基石。

![](/assets/2014-04-03-AspectjStructure2.png "AOP流程模型")

<em>AOP流程模型</em>

----

##四、Aspectj编译机制

Aspectj其实是一个编译器，所以他具有一般编译器所具有的所有组件，但特殊的是，Aspectj分为前端和后端。前端进行的工作是进行词法分析与语法分析，然后分别将.java和.aj文件转化为一个类汇编语言的表示，本质上是一个类三地址无栈表示，称为Jimple IR。由于我们小组三个人都没有学过编译原理，所以对于这个中间概念了解的不是很透彻；而对于后端来说，其实现的工作是在soot框架下将前端的产物，即Jimple IR进行JoinPoint匹配与定位，然后进行织入工作。在这一阶段，后端的最终产物是一个供编译器转换为机器语言的字节码。

以下为我们小组分析所展示的结构前后端原理图：

![](/assets/2014-04-03-AspectjStructure3.png "Aspectj前端工作原理图")

<em>Aspectj前端工作原理图</em>

![](/assets/2014-04-03-AspectjStructure4.png "Aspectj后端工作原理图")

<em>Aspectj后端工作原理图</em>

----

##五、编译转换流程

当然还有经典的银行类 Bank.java用来解释我们为什么会引入AOP这种方式来处理这个问题，但这里就不多说了，网上一搜这方面资料会有一大把的。这一部分主要介绍织入的匹配与流程介绍，配合以下我们小组制出来的两个图进行分析。

![](/assets/2014-04-03-AspectjStructure5.png "Aspectj编译图")

<em>Aspectj编译图</em>

![](/assets/2014-04-03-AspectjStructure6.png "字节码转换图")

<em>字节码转换图</em>

----

##六、架构与风格

在风格上，我们小组认为Aspectj适用于批处理模式、管道过滤器模式以及仓库，因为不管是Aspectj的AJC编译器运行还是结构分析时，我们都发现在这过程中每个处理步骤均独立，数据完全以整体的形式传递。

一个软件在架构上通常分为架构五视图，其分别是：

* 逻辑架构
* 数据架构
* 开发架构
* 物理架构
* 运行架构

结合我们小组的分析方法，我们制定了以下的Aspectj分层架构图，由于制图较早，所以结构分析上还存在较大的不准确。

![](/assets/2014-04-03-AspectjStructure7.png "Aspectj架构图")

<em>Aspectj架构图</em>

----

有关Aspectj的使用教程可以参考：[Aspectj基础学习系列专栏](http://hijiangtao.github.io/2014/03/26/AspectjSeries/)

**声明：**本成果所有权归属于本研究小组，非商业使用权向所有人开放。任何人可以参考我们的分析结构成果并进一步进行研究，因为在研究的过程中，我们也查阅了大量的资料与信息，我们深知分享与奉献的美德以及其重要性，所以我们将自己的成果奉献出来，欢迎大家批评。但任何人不可以将此内容用作任何商业用途，版权所有，仿冒必究。

**作品成果所有权属于课程小组：张梦菲、蒋文慧、李睿、江涛**